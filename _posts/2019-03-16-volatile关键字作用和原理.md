
---
title: volatile关键字作用和原理
tags: java,并发
---
## 作用1 : 提供了变量可见性保证

###### 违反可见性的例子例子

```
//线程a执行的代码
int i = 0;
i = 10;

//线程b执行的代码
j = i;
int y = j += 1

//线程a和线程b在不同的cpu上执行
//线程a修改i的值以后没有立刻将它同步到堆内存中.
//此时线程b执行 j = i，它会先去堆内存读取i的值注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.
//这就是可见性问题，线程a对变量i修改了之后，线程b没有立即看到线程1修改的值.
```

#### 为什么volatile变量能够保证变量的可见性

当写入一个普通的变量时,会先将变量修改后的值写入cpu的高速缓存,然后再同步到堆内存.

在新值写入到堆内存之前,对其他线程是不可见的.此时其他线程读到的仍然是旧值.

而一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰后,当一个线程修改了这个变量的值时,会把修改以后的值立刻同步到堆内存中.从而保证了变量的可见性.




## 作用2.通过内存屏障保证有序性

volatile是通过内存屏障保证有序性的.

观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码(字节码)发现，加入volatile关键字时，会多出一个lock前缀指令

　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：

1. 它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；
	
1. 它会强制将对缓存的修改操作立即写入主存；

3. 如果是写操作，它会导致其他CPU中对应的缓存行无效

## 使用场景

volatile关键字提供了对象的可见性和有序性保证.但是不能用于构建原子操作的复合操作.因此,当一个变量依赖其他变量,或者当变量的新值依赖变量的旧值时,使用volatile变量并不能保证对变量的修改操作不会丢失.

例如,i++看起来像一个原子操作,但是实际上它包含了3个独立的操作,获取变量的当前值,将当前值 +1,写入新值.为了保证更新操作不会丢失,必须保证整个读-写-改操作是原子的.

