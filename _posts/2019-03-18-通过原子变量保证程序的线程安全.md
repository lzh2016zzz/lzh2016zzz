---
title: 通过原子变量保证程序的线程安全
tags: java,读书笔记,并发
---


在java.util.concurrent包中的许多类中,都提供了比synchronized机制更高的性能和可伸缩性.

这种性能提升的主要来源是原子变量和非阻塞的同步机制.

在基于锁的算法中,如果一个线程在休眠或者自旋的同时持有一个锁,那么其他线程都无法继续执行下去.

 而非阻塞算法不会受到单个线程失败的影响.从java5.0开始,可以使用原子变量构建高效的非阻塞算法.



## 锁的劣势

通过使用独占锁,可以保证无论哪个线程持有锁,都能才用独占的方式访问这些变量,并且对变量所做的任何修改在释放锁以后对其他线程都是可见的.

在多个线程同时请求锁时,JVM就要借助操作系统的功能,如果出现这种情况,那么竞争锁失败的线程就会被挂起,并且在稍后恢复线程,在挂起和恢复线程时存在很大的开销.

如果在基于锁的类中包含粗粒度的操作,那么当在锁上存在着激烈的竞争时,调度开销的占比会非常高.



## 原子变量类

原子变量类比锁的粒度更细,量级更轻.原子变量将竞争范围从块级缩小到单个变量上.

更新原子变量的速度(非竞争的情况下)不会比获取锁慢,并且通常会更快.而且不需要挂起或者重新调度线程.在使用基于原子变量而非锁的算法时,线程在执行时更不容易出现延迟,并且在遇到竞争时,也更容易恢复过来.

原子变量相当于一种泛化的volatile,能够支持原子和有条件的读-改-写操作.总共有12个原子变量类,可以分为四种 : 

1. **标量类**

* **AtomicInteger**,**AtomicLong** : 支持算术运算和CAS方法

* **AtomicBoolean** : 用于多线程中安全处理业务逻辑的非锁

* **AtomicReference** : 持有一个对象的引用,并且通过CAS方法操作它.

2. **更新器类**

* **AtomicIntegerFieldUpdater**：基于反射的工具类，可以原子性的更新指定对象的指定int类型字段。

* **AtomicLongFieldUpdater**：基于反射的工具类，可以原子性的更新指定对象的指定long类型字段。

* **AtomicReferenceFieldUpdater**：基于反射的工具类，可以原子性的更新指定对象的指定应用类型字段。

 

###### 关于原子类型字段更新器的使用需要注意一下几个方面

* **字段必须是**volatile**类型的**，用于保证可见性。

* 字段和字段更新器的访问类型(public/protected/private)必须一致,也就是**更新器必须可以直接操作对象字段**.

* **字段只能是实例变量，不能是类变量**(static)。

* **字段不能是**final**的变量**，这样的字段不可修改。

* 对于AtomicIntegerFieldUpdater和AtomicLongFieldUpdater**只能修改**int/long**类型的字段，不能修改其包装类型（**Integer/Long**）**,**如果要处理Integer和Long类型，则需要使用AtomicReferenceFieldUpdater

 

3. **数组类**:

原子数组类(只支持Integer,Long和Reference版本)中的元素可以实现原子更新.原子数组类为数组提供了和volatile相等的访问语义,这是普通数组不具备的特性.


