---
title: 详细了解java并发的三大特性,指令重排序和先行发生原则
tags: 
   - java
   - 读书笔记
   - 并发
---


<!--more-->

## 原子性(Atomicity)

### 定义

如果某个变量 或者 一个或多个命令组成的一系列操作具有原子性,那么在同一个时间只能有一个线程对它进行操作.不会出现多个线程同时修改或者执行某个变量或者方法的情况.


#### 基本类型变量的原子性

基本类型的**赋值**和**获取**操作的原子性由java内存模型保证.


##### 例子

```
int x = 5;//原子操作,将5赋给x
boolean y = true;//原子操作 将true赋给y
int z = 1 + x; //不是原子操作;包含3个操作;获取x的值,将x + 1,将x + 1的计算结果赋给z
x ++;//不是原子操作;包含3个操作,获取x的值,将x的值+ 1,将x + 1的结果赋给x
```

#### 多个命令的原子性

* 通过加锁的机制实现独占,从而保证原子性.

  例子 : **synchronized**关键字,显式锁**ReadWriteLock**,**ReentrantLock**..

#### 违反原子性的例子

```java
public class AtomicityTest {

    private static int i = 1;

    public static void main(String[] args) {
        Thread thread1 = new Thread(() -> mod());
        Thread thread2 = new Thread(() -> mod());
        Thread thread3 = new Thread(() -> mod());
        thread1.start();
        thread2.start();
        thread3.start();
    }

    @SneakyThrows
    public static void mod() {
        for (int n = 0; n < 10; ++n) {
            System.out.println(i++);
            Thread.sleep(10);
        }
    }
  //测试n次
  //第一次: 输出 1,2,3...19,20
  //第二次: 输出 1,2,3...10,1,11,12 ...23
  //第三次输出 1,2,3...9,1,12,12, ...25
  //第三次输出 1,2,3...29
  //可以发现,每次输出的结果都不一样
  //因为i++不是原子操作,在修改i过程中可能i被其它线程修改,
  //所以通过多个线程对变量i进行循环递增时,无法保证i的结果一定能递增到30
  //如何修改?
  //在"i++"操作上加上synchronized关键字:
     /**
     * synchronized(ThreadTest.class) {
     *    System.out.println(i++);
     * }
     */
}
	
```

## 可见性(Visibility)

### 定义

可见性就是指当一个线程修改了线程共享变量的值，其它线程能够立即得知这个修改.

Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方法来实现可见性的.

#### 普通变量的可见性

根据上文可知,普通变量的值的同步需要通过主内存完成.

普通变量在修改完成以后,同步回主内存之前,其他线程读取到的是旧值,所以存在可见性问题.

#### volatile变量的可见性

volatile变量修改以后能立即同步到主内存,以及每次其他线程使用变量前立即从内存读取最新的值.

因此volatile修饰变量保证了线程操作时变量的可见性.

#### 其它保证可见性的技术

* **synchronized**关键字.在同步块结束之前，必须先把块内的变量同步回主内存中.

* **final**关键字.一旦变量初始化完成.那么它的值就不会发生变化,从而保证了变量的可见性.

  

#### 违反可见性的例子 

```
//线程a执行的代码
int i = 0;
i = 10;

//线程b执行的代码
j = i;
int y = j += 1

//线程a和线程b在不同的cpu上执行
//线程a修改i的值以后没有立刻将它同步到堆内存中.
//此时线程b执行 j = i，它会先去堆内存读取i的值注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.
//这就是可见性问题，线程a对变量i修改了之后，线程b没有立即看到线程1修改的值.
```

  

## 有序性(Ordering)

在java内存模型中说过，为了性能优化，编译器和处理器会进行指令重排序.

也就是Java内存模型中的程序天然有序性可以总结为一句话：

如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。

在单例模式的实现上有一种双重检验锁定的方式（Double-checked Locking）。代码如下：

```java
public class Singleton {
    private Singleton() { }
    private volatile static Singleton instance;
    public Singleton getInstance(){
        if(instance==null){
            synchronized (Singleton.class){
                if(instance==null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}

//这里为什么要加volatile了？我们先来分析一下不加volatile的情况，有问题的语句是这条：
//instance = new Singleton();
//这条语句实际上包含了三个操作：1.分配对象的内存空间；2.初始化对象；3.设置instance指向刚分配的内存地址。但由于存在重排序的问题，可能有以下的执行顺序:
//线程A :分配对象的内存空间 => 初始化对象 => 将变量指向刚刚分配的地址
//线程B :判断对象是否为null => 初次访问对象
//如果线程A中初始化对象和 将 变量指向分配的地址 进行了重排序.那么线程B进行判断if(instance==null)时就会为true，而实际上这个instance并没有初始化成功，显而易见对线程B来说之后的操作就会是错得
//volatile关键字使用了内存屏障禁止了指令的重排序语义,因此,具有有序性.
```

## 关于指令重排序

**在程序能得出正确的结果的前提下**,CPU**可以按照任意顺序任意重排指令**。重排序后的指令，对于优化执行以及成熟的全局寄存器分配算法的使用，都是大有裨益的，它使得程序在计算性能上有了很大的提升。

重排序类型包括：

- 编译器生成指令的次序，可以不同于源代码中的行号的顺序
- 处理器可以乱序或者并行的执行指令
- 缓存会改变写入提交到主内存的变量的次序



## 先行发生原则(happens-before) 

Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 先行发生原则.

注意,这里的先行指的不是实际运行时某个动作发生在另一个动作之前,而是指的操作结果的正确性.

如果按照源码顺序,操作A发生在操作B之前,在发生操作B之前,操作A产生的影响能被操作B观察到.

##### 举个例子

```
i = i+1;
j = j+1;
i = i+2;
```

这里i = i + 1逻辑上先于j = j + 1发生，但是由于处理器的优化动作——指令重排序功能和编译器的优化动作——字节码重排序，实际运行的过程中，由于前两句之间没有数据相关，那么j = j + 1实际上可能会发生在i = i + 1之前，但是这并没有改变这段程序的运行结果，因此符合先行发生原则.

另外,先行发生原则只适用于单线程.如果操作A和操作B不在同一个线程,那么就不适用先行发生原则.

1. **程序顺序规则**: 源码顺序中写在前面的操作必须在写在后面的操作之前.

2. **管理锁定规则**：对同一个锁的解锁操作必须在锁操作之后.

3. **volatile变量规则**：对一个变量的写操作先行发生于后面对这个变量的读操作

4. **传递性原则**：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C

5. **线程启动规则**：线程的开始动作必须先于这个线程的所有动作.

6. **线程中断规则**：对线程中断动作必须发生于被中断线程的代码检测到中断事件的发生之前.

7. **线程终结规则**：线程中所有的操作都必须在线程中止之前执行.

8. **对象终结规则**：一个对象的初始化完成先行发生于他的finalize()方法的开始


