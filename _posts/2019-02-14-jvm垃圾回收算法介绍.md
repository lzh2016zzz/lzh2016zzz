
---
title: jvm垃圾回收算法介绍
tags: java,读书笔记
---

# 判断Java中对象是否存活的算法

垃圾回收器在对堆内存回收之前,第一件事就是要确定哪些对象是存活的,哪些对象是可以

被回收的(也就是那些不会再被使用的对象).那么有哪些算法呢?

## 引用计数法

引用计数器算法是给每个对象设置一个计数器，当有地方引用这个对象的时候，计数器+1，当引用失效的时候，计数器-1，当计数器为0的时候，JVM就认为对象不再被使用，可以被回收了。
 引用计数器实现简单，效率高. 但是它有个致命缺陷,无法解决循环引用问题（A对象引用B对象，B对象又引用A对象，但是A,B对象已不被任何其他对象引用)

示例:

```java
//在使用了引用计数法判断对象是否存活的jvm中运行
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int _1MB = 1024 * 1024;
    private byte[] bigSize = new byte[2 * _1MB];
    public static void testGC() {
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();
        objA.instance = objB;
        objB.instance = objA;
        objA = null;
        objB = null;
        //假设在这行发生GC,objA和objB都不会被回收
        System.gc();
    }
}
```

所以在JDK1.1之后，这个算法已经不再使用了.

## 可达性分析算法

也就是通过被称为“GC Root”的对象作为起始点，从这些节点往下开始搜索，当一个对象没有任何引用链到GC Root时，则代表此对象是可以被回收的.目前主流的JVM实现都是通过此法来判断对象是否存活.

###### 可以作为"GC Root"的对象包括以下几种:

* 本地变量,又叫局部变量,也就是方法内定义的变量.

* 静态类属性引用的对象.
* 常量
* JNI引用的对象



# 垃圾回收算法



## 标记-清除算法

标记-清除（Mark-Sweep）算法是现代垃圾回收算法的思想基础。

![](https://gitee.com/minagamiyuki/picgo-gitee/raw/master/images/20200227113602.png)

标记清除算法分为两个阶段,首先通过可达性分析算法标记出所有需要回收的对象，在标记完成以后统一回收所有被标记的对象。

标记清除算法实现简单,但是有两个缺点:

首先标记和清除的过程效率都不高.而且,在清除完以后容易产生空间碎片，空间碎片太多的情况可能导致在分配大对象时可能会因为内存空间不足提前触发第二次GC.


## 标记-整理算法

标记-整理算法是标记-清除算法的改进版本.标记过程和标记-整理算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存(ArrayList 的扩容时的batchRemove() 方法类似这个算法，当然JVM的整理算法要比batchRemove()复杂得多)

![](https://gitee.com/minagamiyuki/picgo-gitee/raw/master/images/20200227113657.png)

它的缺点和标记-清除算法一样,标记的过程效率比较低.但是它的清除过程效率比较高,而且解决了内存碎片导致分配对象效率低下的问题.




## 标记-复制算法

为了解决标记-清除算法的问题.标记-复制算法就出现了.

![](https://gitee.com/minagamiyuki/picgo-gitee/raw/master/images/20200227113634.png)

它将可用内存分为大小相等的2块，每次只使用其中的1块，当这一块的内存用完了，就将存活的对象复制到另一个块，再把使用过的内存清理掉.

这样使得每次垃圾回收都是对某个半区进行回收.内存分配时也不用考虑内存碎片等复杂情况.只需要按顺序分配内存即可.

标记-复制算法优点是实现简单运行高效,但是有两个问题.

因为把内存分为大小相等的两块,所以每次最多使用一半的内存空间,剩下一半内存空间就浪费掉了.代价太过高昂.另外复制算法在对象比较多的时候需要进行比较多的复制操作,效率低下.



## 分代收集算法

当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法，在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用复制算法，而老年代因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记清理”或者“标记整理”算法来进行回收。

![](https://gitee.com/minagamiyuki/picgo-gitee/raw/master/images/20200227113937.png)

图的左半部分是未回收前的内存区域，右半部分是回收后的内存区域.



#### 分配策略

* 对象优先在新生代(Eden)区域分配，如果对象过大直接分配到老年代(Old)区域

* 在多次GC中存活的对象,进入到老年代(Old)区域

  

#### 分代收集算法是如何进行垃圾回收的

* 新生成的对象优先放到新生代(Eden)区,如果对象过大直接分配到老年代(Old)区域

  当Eden空间满时，会触发Minor GC.

* 在Minor GC中存活下来的对象移动到幸存者(Survivor)区.

  幸存者(Survivor)区分成两个部分,survivor0和survivor1.

  Survivor0区满后触发执行Minor GC.存活对象移动到Suvivor1区.

  Survivor0区存活对象移动到Suvivor1区，这样保证了一段时间内总有一个Survivor区为空.另一个不为空的Survivor区没有碎片.

* 经过多次Minor GC仍然存活的对象移动到老年代.

  老年代存储长期存活的对象，占满时会触发Full GC，GC期间会停止所有线程等待GC完成，所以对响应要求高的应用尽量减少发生Major GC，避免响应超时。

#### 如何改进复制算法

> 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生暮死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor 。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。
>  HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。

我的理解,对于web服务器来说,因为其"无状态"的特性,所以大部分对象都是朝生暮死的.

所以在对web服务器做jvm优化时,应该把大部分堆内存分配给Eden空间,这样才能做到最大化利用内存.

对于像游戏服务器这种强状态的服务来说,因为需要保存大量的玩家状态,所以大部分对象存活时间都很长,而存活时间长的对象经过多次GC 都在Old区中. 

为了减少Full GC的频率, 应该把大部分堆内存分配给Old空间.


