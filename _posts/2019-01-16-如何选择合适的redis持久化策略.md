---
title: 如何选择合适的redis持久化策略
tags: redis,读书笔记
---


先介绍一下redis的两种持久化方式

### 1.RDB模式

每隔一段时间保存REDIS存储的数据快照,并且存储到磁盘等介质上.

`SAVE` 和 `BGSAVE` 两个命令都会调用 rdbSave 函数，但它们调用的方式各有不同：

* `SAVE` 直接调用 rdbSave ，阻塞 Redis 主进程，直到保存完成为止。

* `BGSAVE` 则 fork 出一个子进程，子进程负责调用 `rdbSave` ，并在保存完成之后向主进程发送信号，通知保存已完成。

`BGSAVE`时, rdbSave 在子进程被调用，所以 Redis 服务器在 `BGSAVE` 执行期间仍然可以继续处理客户端的请求。
 而在`SAVE`时,服务器是阻塞的,所以当SAVE在执行时,新的命令不会产生任何作用.因此`SAVE`已经基本废弃,在生产环境要杜绝SAVE的使用.


##### RDB模式的优点

* 一旦采用RDB模式,那么整个备份将只会包含一个文件.这对文件备份来说是有利的.比如你可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，我们可以非常容易的进行恢复.

* 数据不太多情况下,效率会略高些。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了.

* 恢复数据效率更高.由于RDB模式是将内存数据的镜像写入到磁盘上,所以恢复数据的速度相对于AOF模式更快一些.

##### RDB模式的缺点

* 如果需要保证数据的绝对一致性,也就是最大限度避免数据丢失.那么RDB将不是一个很好的选择.

  因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失.

*  由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟.

### 2.AOF模式

以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录.

在下次redis重新启动时，只要把这些写指令从前到后再重复执行一遍，就可以实现数据恢复了.

##### AOF模式的优点

* 相对于RDB模式可以带来更好的数据安全性.redis中提供了3种策略,

  其中每秒同步也是异步完成的,效率是很高的.只是一旦出现宕机那么最近1秒写入的数据会丢失.

  而每修改同步可以认为是同步持久化,每次发生的数据变化都会立刻被记录到磁盘里.

* 由于这种模式对日志文件的写入是追加模式,所以即使宕机也不会破坏日志中已经存在的内容.

  如果写入到一半时出现宕机,也可以通过redis自带的工具对备份进行校验.

##### AOF模式的缺点

* 对于相同数量的数据集而言，AOF文件通常要大于RDB文件.RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快
* 根据同步策略的不同，AOF在运行效率上往往会慢于RDB.总之，每秒同步策略的效率是比较高的.



二者选择的标准，就是数据一致性和性能之间的取舍.

看系统是愿意牺牲一些性能,换取更高的数据一致性（aof）,还是愿意写操作频繁的时候，不启用备份来换取更高的性能，待手动运行save的时候，再做备份（rdb）.



### 持久化配置 & 比较

rdb持久化配置:

| **配置命令** | 写入数据是否阻塞 | 保存数据是否阻塞 | **停机时丢失的数据量**           | 说明                                           |
| ------------ | :--------------: | :--------------: | -------------------------------- | ---------------------------------------------- |
| save 900 1   |        Y         |        N         | 最后一次持久化操作之后的所有数据 | 表示900秒内如果有至少1个key变化,则进行持久化.  |
| save 300 10  |        Y         |        N         | 最后一次持久化操作之后的所有数据 | 表示300秒内如果有至少10个key变化,则进行持久化. |

aof持久化配置:

| **配置命令** | 写入数据是否阻塞 | 保存数据是否阻塞 | **停机时丢失的数据量**                                 | 说明                                     |
| ------------------------------------------------------------ | :--------------: | :--------------: | ------------------------------------------------------ | ---------------------------------------- |
| appendfsync no                                               |        Y         |        Y         | 操作系统最后一次对  AOF 文件触发 SAVE 操作之后的数据 | 从不同步。需要调用`SAVE`或者`BGSAVE`触发 |
| appendfsync everysec                                     |        Y         |        N         | 不超过1秒钟的数据                      | 每1秒钟同步一次，该策略为AOF的缺省策略   |
| appendfsync always                                           |        Y         |        Y         | 最多只丢失一个命令的数据                             | 每次有数据修改发生时都会写入AOF文件      |

 

