---
title: mysql索引类型和优化
tags: 
   - mysql
   - 读书笔记
---


### 关于Msql的索引类型

先解释一下索引的重要性,如果正确合理的设计并使用索引的Msql是一辆兰博基尼的话,那么没有设计和使用索引的Mysql就是一辆破三轮车.

对于没有索引的表,单表查询可能几十万条数据就是瓶颈了.原因是在查询时,两张无关联条件的表会因为全表扫描发生笛卡尔积.假设表a有1000条数据,表b有2000条数据,那么扫描的行数就是1000 * 2000 = 2000000行.

当然,在数据量真的很少的情况下,会出现笛卡尔积比走索引快的情况.这种情况下也就不用考虑所谓的优化问题了.

而一般的大中型网站单日可能就会产生几十万甚至上百万条的数据,没有索引查询就会变得非常缓慢.

#### B-tree索引(默认索引)

 Btree是一种是为磁盘等外存储设备设计的一种平衡查找树.在create table时,如果没有指定索引类型,会默认使用该类型.大多数mysql引擎都支持这种索引.
不同的存储引擎会以不同的方式使用b-tree索引.性能也各有不同,各有优劣.例如 MyISAM使用前缀压缩技术使得索引更小.而InnoDB则按照源数据格式进行存储.再如MyISAM通过数据的物理位置引用被索引的行,而InnoDB则根据主键引用被索引的行.
B-tree意味着所有值都是按顺序存储的.并且每一个叶子页到根的距离相同.B-tree索引能够加快数据的访问速度,因为存储引擎不再需要扫描全表,取而代之的是通过索引的根节点进行搜索.
B-tree索引支持的查询类型 : 

 *  **全列匹配**.也就是和索引中的所有列进行匹配.
 *   **最左前缀匹配**.也就是可以使用索引最左开始的n个列进行查询.
 *   **匹配范围值**.

B-tree索引的限制 :

* **最左前缀原则**.也就是最左优先,在检索数据时从联合索引的最左边开始匹配

  举个例子 :

  ```mysql
  #建立索引indexs(col1,col2,col3)
  #这个联合索引实际上相当于建立了(col1),(col1,col2),(col1,col2,col3) 3个索引
  KEY indexs on test(col1,col2,col3);
  #现在有如下查询
  SELECT * FROM table1 WHERE col1=“1” AND clo2=“2” AND clo4=“4”
  #那么上面这个语句会遵循最左前缀原则,检索时会使用(col1,col2)进行匹配
  ```

* **不能跳过索引中的列**.假设有联合索引A,B,C,D,如果查询条件不指定C,则Mysql只能使用索引的A,B列.
  因为这些限制,在优化性能时,可能需要创建相同的列但顺序不同的索引来满足不同类型的查询需求.

  举个例子 : 

  ```mysql
  #建立索引indexs(col1,col2,col3)
  #这个联合索引实际上相当于建立了(col1),(col1,col2),(col1,col2,col3) 3个索引
  KEY indexs on test(col1,col2,col3);
  #现在有如下查询
  SELECT * FROM table1 WHERE col1=“1” AND clo3=“2”
  #因为缺少col2,所以检索时只能使用(col1)进行匹配
  ```

  

#### 哈希索引

哈希索引基于哈希表实现.只有精确匹配索引的所有列的查询才有效.对于每一行数据,哈希索引都会根据所有的索引列计算一个hash code.
哈希索引会将所有的hash code存储在索引中,同时在哈希表中保存指向每个数据行的指针.

因为索引本身只存储hash code,所以索引的结构十分紧凑,这也让哈希表的速度非常快.然而.哈希表也有它的限制:
 * **不支持排序**.
 * **不支持覆盖索引**.
 * **不支持通过部分索引列进行查找**.
 * **不支持范围查询**,只支持等值比较查询.
 * **哈希碰撞可能导致的性能下降问题**.
 * **存储的是指向数据行的指针**，所以不支持覆盖索引.
  因为这些限制,哈希表只适用于某些特定的场合.而一旦适用哈希索引,它带来的性能提升会非常显著.比如,在关联多个表查询时的中间表,哈希索引就非常适合它的需求.

#### 全文索引

MySQL从3.23.23版开始支持全文索引和全文检索，FULLTEXT索引仅可用于 MyISAM 表；

他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加。

对于较大的数据集，将你的资料输入一个没有FULLTEXT索引的表中，然后创建索引，其速度比把资料输入现有FULLTEXT索引的速度更为快。不过切记对于大容量的数据表，生成全文索引是一个非常消耗时间非常消耗硬盘空间的做法。

它更类似搜索引擎,而不是简单的where匹配.



### 关于索引的优化

以上说的都是索引的好处.但是过多使用索引会导致滥用.因此索引也有它的缺点,虽然索引提高了表的查询速度,但是同时会降低表的更新速度.

因为在更新表时,mysql不但要保存数据,还要更新索引文件.一般这个问题不太严重.但是你如果在一张大表上建立了很多索引.索引文件会膨胀的很快.

下面是一些我总结和收藏的优化索引的方法:

* **使用前缀索引索引开始的部分字符，这样可以大大节省索引空间，从而提高索引效率。**

  当索引是很长的字符序列时,这个索引将会很占内存,而且会很慢,这时候就会用到*前缀索引*了.所谓的前缀索引就是以字段前面几个字符作为索引.这样可以大大节省索引空间,从而提高索引效率.

* **使用覆盖索引**

  **覆盖索引**（**covering index**）指一个查询语句的结果只用从索引中就能够取得，不必从数据表中读取.覆盖索引可以极大的提升性能

* **尽量避免同时使用多个范围条件**

  众所周知,mysql无法同时使用多个索引

* **尽量减少like语句的使用**

  如果非使用不可，如何使用也是一个问题。like “%aaa%” 不会使用索引而like “aaa%”可以使用索引。
